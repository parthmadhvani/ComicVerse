AWSTemplateFormatVersion: '2010-09-09'
Description: CloudFormation template for Term project

# Name: Nikul Kukadiya (B00981020)
#
#  Services i used in my cloudformation and the applications are as below
# Application Name: ComicVerse
# Purpose: A platform where users can create and read the comic books.

# Compute pick 2
#   aws ec2 => Hosting of the application
#   aws lambda => All the apis of backend created using the lambda
# Storage pick 1
#   aws s3 => All the generated comic files are stored in S3 bucket
#   aws dynamodb => All the user data will be stored in dynamodb
# Network pick 1
#   API Gateway => Lambda functions are connected using API Gateway to configure it in frontend
#   VPC => Create public and private subnet to host the react application
# General
#   AWS SNS => For subscription of the particular comic category and will receive emails when new comic added for the same
#   AWS SQ=> When user is writing the comic during comic creation then the PDF file will be generated from that text
#              and will be stored in s3 bucket. As this process takes a lot of time SQS queue will be beneficial to handle
#              the load.



# Predefined parameters
Parameters:
  Stage:
    Type: String
    Default: term1
  RoleARN:
    Type: String
    Default: "arn:aws:iam::998689998714:role/LabRole"
  Region:
    Type: String
    Default: "us-east-1"
  VpcCIDR:
    Type: String
    Default: "10.0.0.0/16"
    Description: CIDR block for the VPC
  PublicSubnetCIDR:
    Type: String
    Default: "10.0.1.0/24"
    Description: CIDR block for the public subnet
  PrivateSubnetCIDR:
    Type: String
    Default: "10.0.2.0/24"
    Description: CIDR block for the private subnet
  AvailabilityZone:
    Type: String
    Default: "a"
    Description: Availability Zone for the subnets

Resources:

#  Tables
  UserTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "UserTable-${Stage}"
      AttributeDefinitions:
        - AttributeName: 'email'
          AttributeType: 'S'
      KeySchema:
        - AttributeName: 'email'
          KeyType: 'HASH'
      ProvisionedThroughput:
        ReadCapacityUnits: 5
        WriteCapacityUnits: 5

  ComicTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "ComicTable-${Stage}"
      AttributeDefinitions:
        - AttributeName: 'id'
          AttributeType: 'S'
      KeySchema:
        - AttributeName: 'id'
          KeyType: 'HASH'
      ProvisionedThroughput:
        ReadCapacityUnits: 5
        WriteCapacityUnits: 5

  UserSubscriptionTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName:  !Sub "user_subscription-${Stage}"
      AttributeDefinitions:
        - AttributeName: email
          AttributeType: S
        - AttributeName: subscription_name
          AttributeType: S
      KeySchema:
        - AttributeName: email
          KeyType: HASH
        - AttributeName: subscription_name
          KeyType: RANGE
      ProvisionedThroughput:
        ReadCapacityUnits: 5
        WriteCapacityUnits: 5

#SQS
  ComicProcessingQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub "ComicProcessingQueue-${Stage}"
      VisibilityTimeout: 300   # Set the visibility timeout slightly higher than Lambda function timeout

#S3 bucket
  ComicS3Bucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "comic-bucket-term-project-${Stage}"
      AccessControl: Private

#SNS Topics
  SuperheroTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: Superhero Comics SNS Topic

  FantasyTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: Fantasy Comics SNS Topic

  SciFiTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: Sci-Fi Comics SNS Topic

  MysteryTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: Mystery Comics SNS Topic


#Lambda functions, permissions, gateway resource, API Method

  # Get login function
  GetLoginFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: "index.handler"
      Role: !Sub "${RoleARN}"
      Runtime: nodejs20.x
      MemorySize: 128
      Timeout: 30
      Environment:
        Variables:
          USERS_TABLE_NAME: !Ref UserTable
      Code:
        ZipFile: |
          const { DynamoDBClient, GetItemCommand, ScanCommand } = require('@aws-sdk/client-dynamodb');
          const { marshall, unmarshall } = require('@aws-sdk/util-dynamodb');
          
          const db = new DynamoDBClient({ region: process.env.AWS_REGION });
          
          exports.handler = async (event) => {
              const response = {
                statusCode: 200,
                headers: {
                  "Access-Control-Allow-Origin": "*",
                  "Access-Control-Allow-Headers": "Content-Type",
                  "Access-Control-Allow-Methods": "*"
                }
              };
          
              try {
                  const eventBody = event.queryStringParameters;
          
                  const params = {
                      TableName: process.env.USERS_TABLE_NAME,
                      FilterExpression: 'email = :email',
                      ExpressionAttributeValues: {
                          ':email': { S: eventBody.email }
                      }
                  };
          
                  const Item = await db.send(new ScanCommand(params));
          
                  console.log({ Item });
          
                  if (Item.Items.length === 0) {
                    return {
                      statusCode: 404,
                      headers: {
                        "Access-Control-Allow-Origin": "*",
                        "Access-Control-Allow-Headers": "Content-Type",
                        "Access-Control-Allow-Methods": "*"
                      },
                      body: JSON.stringify({ message: 'User not found' }),
                    };
                  }
                  const user = unmarshall(Item.Items[0]);
          
                  if (user.password !== eventBody.password) {
                    return {
                      statusCode: 401,
                      headers: {
                        "Access-Control-Allow-Origin": "*",
                        "Access-Control-Allow-Headers": "Content-Type",
                        "Access-Control-Allow-Methods": "*"
                      },
                      body: JSON.stringify({ message: 'Invalid password' })
                    };
                  }
          
                  response.body = JSON.stringify({
                      message: "Successfully retrieved user.",
                      data: user,
                  });
              } catch (e) {
                  console.error(e);
                  response.statusCode = 500;
                  response.body = JSON.stringify({
                      message: "Failed to get user.",
                      errorMsg: e.message,
                      errorStack: e.stack,
                  });
              }
              return response;
          };
  
  



  # Get login gateway resource
  ApiGatewayResourceLogin:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: login-user

  # Get login Method
  ApiGatewayMethodLogin:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceLogin
      HttpMethod: GET
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters:
        "method.request.path.proxy": true
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'GET,POST,PUT,DELETE,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceLogin
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${GetLoginFunction.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,POST,PUT,DELETE,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: { }

  # Get login Lambda Permission
  GetLoginFunctionInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt GetLoginFunction.Arn
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayRestApi}/*/*/*"

  # Signup Lambda function
  SignupFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: "index.handler"
      Role: !Sub "${RoleARN}"
      Runtime: nodejs20.x
      MemorySize: 128
      Timeout: 30
      Environment:
        Variables:
          USERS_TABLE_NAME: !Ref UserTable
      Code:
        ZipFile: |
          const { DynamoDBClient, PutItemCommand, GetItemCommand } = require('@aws-sdk/client-dynamodb');
          const { marshall } = require('@aws-sdk/util-dynamodb');
          
          const db = new DynamoDBClient({ region: process.env.AWS_REGION });
          
          exports.handler = async (event) => {
              const response = {
                statusCode: 200,
                headers: {
                  "Access-Control-Allow-Origin": "*",
                  "Access-Control-Allow-Headers": "Content-Type",
                  "Access-Control-Allow-Methods": "*"
                }
              };
          
              try {
                  const eventBody = JSON.parse(event.body);
          
                  const existingUserParams = {
                      TableName: process.env.USERS_TABLE_NAME,
                      Key: {
                          'email': { S: eventBody.email }
                      }
                  };
          
                  const existingUser = await db.send(new GetItemCommand(existingUserParams));
          
                  if (existingUser.Item) {
                      return {
                          statusCode: 400,
                          headers: {
                              "Access-Control-Allow-Origin": "*",
                              "Access-Control-Allow-Headers": "Content-Type",
                              "Access-Control-Allow-Methods": "*"
                          },
                          body: JSON.stringify({ message: 'User with this email already exists' }),
                      };
                  }
          
                  const newUserParams = {
                      TableName: process.env.USERS_TABLE_NAME,
                      Item: marshall({
                          'email': eventBody.email,
                          'password': eventBody.password,
                          'firstname': eventBody.firstname,
                          'lastname': eventBody.lastname,
                          'profilepicture': eventBody.profilepicture,
                      })
                  };
          
                  await db.send(new PutItemCommand(newUserParams));
          
                  response.body = JSON.stringify({
                      message: "User successfully registered.",
                      email: eventBody.email,
                      firstname: eventBody.firstname,
                      lastname: eventBody.lastname,
                      profilepicture: eventBody.profilepicture
                  });
              } catch (e) {
                  console.error(e);
                  response.statusCode = 500;
                  response.body = JSON.stringify({
                      message: "Failed to register user.",
                      errorMsg: e.message,
                      errorStack: e.stack,
                  });
              }
              return response;
          };





  # Signup gateway resource
  ApiGatewayResourceSignup:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: signup-user

  # Signup Method
  ApiGatewayMethodSignup:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceSignup
      HttpMethod: POST
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters:
        "method.request.path.proxy": true
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceSignup
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${SignupFunction.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: { }

  # Signup Lambda Permission
  SignupFunctionInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt SignupFunction.Arn
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayRestApi}/*/*/*"

  # Get user profile Lambda function
  GetUserProfileFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: "index.handler"
      Role: !Sub "${RoleARN}"
      Runtime: nodejs20.x
      MemorySize: 128
      Timeout: 30
      Environment:
        Variables:
          USERS_TABLE_NAME: !Ref UserTable
      Code:
        ZipFile: |
          const { DynamoDBClient, ScanCommand } = require('@aws-sdk/client-dynamodb');
          const { unmarshall } = require('@aws-sdk/util-dynamodb');
          
          const db = new DynamoDBClient({ region: process.env.AWS_REGION });
          
          exports.handler = async (event) => {
              const response = {
                  statusCode: 200,
                  headers: {
                      "Access-Control-Allow-Origin": "*",
                      "Access-Control-Allow-Headers": "Content-Type",
                      "Access-Control-Allow-Methods": "*"
                  }
              };
          
              try {
                  console.log("Event:", JSON.stringify(event));
          
                  const eventBody = event.queryStringParameters;
                  const email = eventBody.email;
          
                  console.log("Email:", email);
          
                  // Scan parameters
                  const params = {
                      TableName: process.env.USERS_TABLE_NAME,
                      FilterExpression: 'email = :email',
                      ExpressionAttributeValues: {
                          ':email': { S: email }
                      }
                  };
          
                  const result = await db.send(new ScanCommand(params));
          
                  if (result.Items.length === 0) {
                      return {
                          statusCode: 404,
                          headers: response.headers,
                          body: JSON.stringify({ message: 'User not found' }),
                      };
                  }
          
                  response.body = JSON.stringify({
                      message: "Successfully retrieved user profile.",
                      data: unmarshall(result.Items[0]),
                  });
              } catch (e) {
                  console.error(e);
                  response.statusCode = 500;
                  response.body = JSON.stringify({
                      message: "Failed to get user profile.",
                      errorMsg: e.message,
                      errorStack: e.stack,
                  });
              }
              return response;
          };




  # Get user profile gateway resource
  ApiGatewayResourceUserProfile:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: user-profile

  # Get user profile Method
  ApiGatewayMethodUserProfile:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceUserProfile
      HttpMethod: GET
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters:
        "method.request.path.proxy": true
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceUserProfile
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${GetUserProfileFunction.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: { }

  # Get user profile Lambda Permission
  GetUserProfileFunctionInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt GetUserProfileFunction.Arn
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayRestApi}/*/*/*"

  # Comic Creation Lambda function
  ComicCreationFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: "index.handler"
      Role: !Sub "${RoleARN}"
      Runtime: nodejs20.x  # Adjust runtime version as needed
      MemorySize: 128
      Timeout: 300
      Environment:
        Variables:
          COMIC_TABLE_NAME: !Ref ComicTable
          SQS_QUEUE_NAME: !Ref ComicProcessingQueue
          SuperheroTopicArn: !Ref SuperheroTopic
          FantasyTopicArn: !Ref FantasyTopic
          SciFiTopicArn: !Ref SciFiTopic
          MysteryTopicArn: !Ref MysteryTopic
          BUCKET_NAME: !Ref ComicS3Bucket
      Code:
        ZipFile: |
                 const { DynamoDBClient, PutItemCommand, GetItemCommand } = require('@aws-sdk/client-dynamodb');
                          const { marshall } = require('@aws-sdk/util-dynamodb');
                          const { SQSClient, SendMessageCommand } = require('@aws-sdk/client-sqs');
                          const { SNSClient, PublishCommand } = require('@aws-sdk/client-sns');
                          const { S3Client, PutObjectCommand } = require('@aws-sdk/client-s3');
                          const crypto = require('crypto');
                        
                        const db = new DynamoDBClient({ region: process.env.AWS_REGION });
                        const sqs = new SQSClient({ region: process.env.AWS_REGION });
                        const sns = new SNSClient({ region: process.env.AWS_REGION });
                        const s3 = new S3Client({ region: process.env.AWS_REGION });
                          
                          exports.handler = async (event) => {
                          const response = {
                        statusCode: 200,
                        headers: {
                          "Access-Control-Allow-Origin": "*",
                          "Access-Control-Allow-Headers": "Content-Type",
                          "Access-Control-Allow-Methods": "*"
                        }
                        };
                          
                          try {
                          const eventBody = JSON.parse(event.body);
                          
                          // Check if comic with the same ID exists
                          const existingComicParams = {
                        TableName: process.env.COMIC_TABLE_NAME,
                        Key: {
                          'id': { S: eventBody.id }
                        }
                        };
                          
                          const existingComic = await db.send(new GetItemCommand(existingComicParams));
                          
                          if (existingComic.Item) {
                          return {
                        statusCode: 400,
                        headers: {
                          "Access-Control-Allow-Origin": "*",
                          "Access-Control-Allow-Headers": "Content-Type",
                          "Access-Control-Allow-Methods": "*"
                        },
                        body: JSON.stringify({ message: 'Comic with this ID already exists' }),
                        };
                        }
                          
                          // Prepare new comic item
                          let pdfUrl = null;
                          if (eventBody.pdfFile) {
                          const pdfData = Buffer.from(eventBody.pdfFile, 'base64');
                          const pdfKey = `comics/${eventBody.id}.pdf`;
                          
                          const uploadParams = {
                        Bucket: process.env.BUCKET_NAME,
                        Key: pdfKey,
                        Body: pdfData,
                        ContentType: 'application/pdf'
                        };
                          
                          await s3.send(new PutObjectCommand(uploadParams));
                          pdfUrl = `https://${process.env.BUCKET_NAME}.s3.amazonaws.com/${pdfKey}`;
                        }
                          
                          const newComicParams = {
                        TableName: process.env.COMIC_TABLE_NAME,
                        Item: marshall({
                          'id': eventBody.id,
                          'name': eventBody.name,
                          'author': eventBody.author,
                          'category': eventBody.category,
                          'comicText': eventBody.comicText || null,
                          'createdAt': new Date().toISOString(),
                          'updatedAt': new Date().toISOString(),
                          'image': eventBody.image,
                          'description': eventBody.description,
                          'pdfUrl': pdfUrl
                        })
                        };
                          
                          await db.send(new PutItemCommand(newComicParams));
                          
                          response.body = JSON.stringify({
                        message: "Comic successfully created.",
                        comicId: eventBody.id,
                        name: eventBody.name,
                        author: eventBody.author
                        });
                          
                          // Publish to SNS topic based on category
                          let topicArn;
                          switch (eventBody.category) {
                        case 'Superhero':
                          topicArn = process.env.SuperheroTopicArn;
                          break;
                        case 'Fantasy':
                          topicArn = process.env.FantasyTopicArn;
                          break;
                        case 'Sci-Fi':
                          topicArn = process.env.SciFiTopicArn;
                          break;
                        case 'Mystery':
                          topicArn = process.env.MysteryTopicArn;
                          break;
                        default:
                          throw new Error(`Unsupported category: ${eventBody.category}`);
                        }
                          
                          // Remove pdfFile from the eventBody
                          const snsMessageBody = { ...eventBody };
                          delete snsMessageBody.pdfFile;
                          delete snsMessageBody.comicText;
                          
                          const snsParams = {
                        TopicArn: topicArn,
                        Message: JSON.stringify(snsMessageBody)
                        };
                          
                          await sns.send(new PublishCommand(snsParams));
                          
                          // Send message to SQS queue (optional)
                          if (process.env.SQS_QUEUE_NAME && pdfUrl ==null ) {
                          
                          const sqsMessageBody = { ...eventBody };
                          delete sqsMessageBody.pdfFile;
                          
                          const sqsParams = {
                        QueueUrl: process.env.SQS_QUEUE_NAME,
                        MessageBody: JSON.stringify(sqsMessageBody)
                        };
                          
                          await sqs.send(new SendMessageCommand(sqsParams));
                        }
                        
                        } catch (e) {
                          console.error(e);
                          response.statusCode = 500;
                          response.body = JSON.stringify({
                        message: "Failed to create comic.",
                        errorMsg: e.message,
                        errorStack: e.stack,
                        });
                        }
                          
                          return response;
                        };
        








# Comic Creation Gateway resource
  ApiGatewayResourceComicCreation:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: create-comic

  # Comic Creation Method
  ApiGatewayMethodComicCreation:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceComicCreation
      HttpMethod: POST
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters:
        "method.request.path.proxy": true
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceComicCreation
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ComicCreationFunction.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: { }

  # Comic Creation Lambda Permission
  ComicCreationFunctionInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt ComicCreationFunction.Arn
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayRestApi}/*/*/*"

  GetComicFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: "index.handler"
      Role: !Sub "${RoleARN}"
      Runtime: nodejs20.x  # Adjust runtime version as needed
      MemorySize: 128
      Timeout: 30
      Environment:
        Variables:
          COMIC_TABLE_NAME: !Ref ComicTable
      Code:
        ZipFile: |
          const { DynamoDBClient, ScanCommand } = require('@aws-sdk/client-dynamodb');
          const { unmarshall } = require('@aws-sdk/util-dynamodb');
          
          const db = new DynamoDBClient({ region: process.env.AWS_REGION });
          
          exports.handler = async (event) => {
            const response = {
              statusCode: 200,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Content-Type",
                "Access-Control-Allow-Methods": "*"
              }
            };
          
            try {
              const { lastEvaluatedKey } = event.queryStringParameters || {};
              const limit = 20;
          
              const params = {
                TableName: process.env.COMIC_TABLE_NAME,
                Limit: limit,
                ExclusiveStartKey: lastEvaluatedKey ? JSON.parse(decodeURIComponent(lastEvaluatedKey)) : undefined
              };
          
              const data = await db.send(new ScanCommand(params));
              const comics = data.Items.map(item => unmarshall(item));
          
              response.body = JSON.stringify({
                message: "Successfully retrieved comics.",
                data: comics,
                lastEvaluatedKey: data.LastEvaluatedKey ? encodeURIComponent(JSON.stringify(data.LastEvaluatedKey)) : null
              });
            } catch (e) {
              console.error(e);
              response.statusCode = 500;
              response.body = JSON.stringify({
                message: "Failed to get comics.",
                errorMsg: e.message,
                errorStack: e.stack,
              });
            }
            return response;
          };



  # API Gateway resource for comics
  ApiGatewayResourceComic:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: comics

  # API Gateway method for retrieving comics
  ApiGatewayMethodComic:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceComic
      HttpMethod: GET
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters:
        "method.request.path.proxy": true
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'GET,POST,PUT,DELETE,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceComic
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${GetComicFunction.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,POST,PUT,DELETE,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: { }

  # Lambda permission for API Gateway to invoke GetComicFunction
  GetComicFunctionInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt GetComicFunction.Arn
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayRestApi}/*/*/*"

  # Lambda Function to like a comic
  LikeComicFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: "index.handler"
      Role: !Sub "${RoleARN}"
      Runtime: nodejs20.x  # Adjust runtime version as needed
      MemorySize: 128
      Timeout: 30
      Environment:
        Variables:
          COMIC_TABLE_NAME: !Ref ComicTable
      Code:
        ZipFile: |
          const { DynamoDBClient, UpdateItemCommand } = require('@aws-sdk/client-dynamodb');
          const { marshall, unmarshall } = require('@aws-sdk/util-dynamodb');

          const db = new DynamoDBClient({ region: process.env.AWS_REGION });

          exports.handler = async (event) => {
            const response = {
              statusCode: 200,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Content-Type",
                "Access-Control-Allow-Methods": "*"
              }
            };

            try {
              const { comicId } = JSON.parse(event.body);

              const params = {
                TableName: process.env.COMIC_TABLE_NAME,
                Key: marshall({ id: comicId }),
                UpdateExpression: "SET #likes = if_not_exists(#likes, :zero) + :incr",
                ExpressionAttributeNames: {
                  "#likes": "likes"
                },
                ExpressionAttributeValues: marshall({
                  ":incr": 1,
                  ":zero": 0
                }),
                ReturnValues: "UPDATED_NEW"
              };

              const data = await db.send(new UpdateItemCommand(params));
              const updatedComic = unmarshall(data.Attributes);

              response.body = JSON.stringify({
                message: "Successfully liked the comic.",
                data: updatedComic,
              });
            } catch (e) {
              console.error(e);
              response.statusCode = 500;
              response.body = JSON.stringify({
                message: "Failed to like the comic.",
                errorMsg: e.message,
                errorStack: e.stack,
              });
            }
            return response;
          };




  # API Gateway Resource for liking a comic
  ApiGatewayResourceLikeComic:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: like-comic

  # API Gateway Method for liking a comic
  ApiGatewayMethodLikeComic:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceLikeComic
      HttpMethod: POST
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters:
        "method.request.path.proxy": true
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceLikeComic
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LikeComicFunction.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: { }

  # Lambda Permission for API Gateway to invoke LikeComicFunction
  LikeComicFunctionInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt LikeComicFunction.Arn
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayRestApi}/*/*/*"

  SubscribeToComicTopicFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !Sub "${RoleARN}"
      Runtime: nodejs20.x
      MemorySize: 128
      Timeout: 30
      Environment:
        Variables:
          SuperheroTopicArn: !Ref SuperheroTopic
          FantasyTopicArn: !Ref FantasyTopic
          SciFiTopicArn: !Ref SciFiTopic
          MysteryTopicArn: !Ref MysteryTopic
          USER_TABLE_NAME: !Ref UserTable
      Code:
        ZipFile: |
          const { SNSClient, SubscribeCommand, UnsubscribeCommand, ListSubscriptionsByTopicCommand } = require('@aws-sdk/client-sns');
                  const { DynamoDBClient, GetItemCommand, UpdateItemCommand } = require('@aws-sdk/client-dynamodb');
                
                const snsClient = new SNSClient({ region: process.env.AWS_REGION });
                const dbClient = new DynamoDBClient({ region: process.env.AWS_REGION });
                  
                  exports.handler = async (event) => {
                  
                  
                  const response = {
                statusCode: 200,
                headers: {
                  "Access-Control-Allow-Origin": "*",
                  "Access-Control-Allow-Headers": "Content-Type",
                  "Access-Control-Allow-Methods": "*"
                }
                };
                  
                  console.log('Event received:', event);
                  
                  const { email, category, action } = JSON.parse(event.body);
                  console.log('Parsed event body:', { email, category, action });
                  
                  let topicArn;
                  switch (category) {
                case 'Superhero':
                  topicArn = process.env.SuperheroTopicArn;
                  break;
                case 'Fantasy':
                  topicArn = process.env.FantasyTopicArn;
                  break;
                case 'Sci-Fi':
                  topicArn = process.env.SciFiTopicArn;
                  break;
                case 'Mystery':
                  topicArn = process.env.MysteryTopicArn;
                  break;
                default:
                  return {
                  statusCode: 400,
                  headers: response.headers,
                  body: JSON.stringify({ message: 'Invalid category provided' }),
                };
                }
                  
                  try {
                  // Retrieve current user from DynamoDB
                  const getParams = {
                TableName: process.env.USER_TABLE_NAME,
                Key: { email: { S: email } },
                };
                  const { Item } = await dbClient.send(new GetItemCommand(getParams));
                  
                  // Check if the user exists
                  if (!Item) {
                  console.log('User not found:', email);
                  return {
                statusCode: 404,
                  headers: response.headers,
                body: JSON.stringify({ message: 'User not found' }),
                };
                }
                  
                  const existingCategories = Item?.category?.S || '';
                  const categoriesArray = existingCategories.split(',').map(cat => cat.trim().toLowerCase());
                  
                  if (action === 'remove') {
                  // Remove the category if it exists
                  if (categoriesArray.includes(category.toLowerCase())) {
                  // List subscriptions by topic to find the SubscriptionArn
                  const listParams = {
                TopicArn: topicArn,
                };
                  const listSubscriptionsCommand = new ListSubscriptionsByTopicCommand(listParams);
                  const listSubscriptionsResponse = await snsClient.send(listSubscriptionsCommand);
                  
                  const subscription = listSubscriptionsResponse.Subscriptions.find(sub => sub.Endpoint === email);
                  
                  if (subscription && subscription.SubscriptionArn && subscription.SubscriptionArn.split(':').length >= 6) {
                  const unsubscribeParams = {
                SubscriptionArn: subscription.SubscriptionArn,
                };
                  const unsubscribeCommand = new UnsubscribeCommand(unsubscribeParams);
                  await snsClient.send(unsubscribeCommand);
                  console.log('User unsubscribed from SNS topic:', { email, topicArn });
                }
                  
                  // Remove the category from the list
                  const updatedCategories = categoriesArray.filter(cat => cat !== category.toLowerCase()).join(',');
                  
                  // Update the DynamoDB table
                  const updateParams = {
                TableName: process.env.USER_TABLE_NAME,
                Key: { email: { S: email } },
                UpdateExpression: 'SET category = :category',
                ExpressionAttributeValues: {
                  ':category': { S: updatedCategories },
                },
                ReturnValues: 'ALL_NEW',
                };
                  const data = await dbClient.send(new UpdateItemCommand(updateParams));
                  const updatedUser = data.Attributes;
                  console.log('User table updated in DynamoDB:', updatedUser);
                  
                  return {
                statusCode: 200,
                  headers: response.headers,
                body: JSON.stringify({
                  message: `Successfully removed category ${category} for user and unsubscribed from topicArn ${topicArn}.`,
                  data: updatedUser,
                }),
                };
                } else {
                  console.log('Category not found in the user\'s subscription list.');
                  return {
                statusCode: 404,
                  headers: response.headers,
                body: JSON.stringify({
                  message: `Category ${category} not found in user's subscription list.`,
                }),
                };
                }
                } else {
                  // Check if the category already exists
                  if (!categoriesArray.includes(category.toLowerCase())) {
                  // Subscribe user to SNS topic
                  const subscribeParams = {
                Protocol: 'email',
                TopicArn: topicArn,
                Endpoint: email,
                };
                  const subscribeCommand = new SubscribeCommand(subscribeParams);
                  await snsClient.send(subscribeCommand);
                  console.log('User subscribed to SNS topic:', { email, topicArn });
                  
                  // Append the new category
                  categoriesArray.push(category.toLowerCase());
                  const updatedCategories = categoriesArray.join(',');
                  
                  // Update the DynamoDB table with the new category
                  const updateParams = {
                TableName: process.env.USER_TABLE_NAME,
                Key: { email: { S: email } },
                UpdateExpression: 'SET category = :category',
                ExpressionAttributeValues: {
                  ':category': { S: updatedCategories },
                },
                ReturnValues: 'ALL_NEW',
                };
                  const data = await dbClient.send(new UpdateItemCommand(updateParams));
                  const updatedUser = data.Attributes;
                  console.log('User table updated in DynamoDB:', updatedUser);
                  
                  return {
                statusCode: 200,
                  headers: response.headers,
                body: JSON.stringify({
                  message: `Successfully updated user with category ${category} and topicArn ${topicArn}.`,
                  data: updatedUser,
                }),
                };
                } else {
                  console.log('Category already exists for the user.');
                  return {
                statusCode: 200,
                  headers: response.headers,
                body: JSON.stringify({
                  message: `Category ${category} already exists for user.`,
                }),
                };
                }
                }
                } catch (error) {
                  console.error('Error subscribing/unsubscribing from SNS topic or updating DynamoDB:', error);
                  return {
                statusCode: 500,
                  headers: response.headers,
                body: JSON.stringify({
                  message: 'Failed to subscribe/unsubscribe from SNS topic or update DynamoDB',
                  error: error.message,
                  stack: error.stack,
                }),
                };
                }
                };







# API Gateway Resource for subscribing to comic topics
  ApiGatewayResourceSubscribe:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: subscribe

  # API Gateway Method for subscribing to comic topics
  ApiGatewayMethodSubscribe:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceSubscribe
      HttpMethod: POST
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters:
        "method.request.path.proxy": true
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceSubscribe
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${SubscribeToComicTopicFunction.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: { }

  # Lambda Permission for API Gateway to invoke SubscribeToComicTopicFunction
  SubscribeToComicTopicFunctionInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt SubscribeToComicTopicFunction.Arn
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayRestApi}/*/*/*"

  # Lambda Function to update user profile
  UpdateUserProfileFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: "index.handler"
      Role: !Sub "${RoleARN}"
      Runtime: nodejs20.x  # Adjust runtime version as needed
      MemorySize: 128
      Timeout: 30
      Environment:
        Variables:
          USER_TABLE_NAME: !Ref UserTable
      Code:
        ZipFile: |
          const { DynamoDBClient, UpdateItemCommand } = require('@aws-sdk/client-dynamodb');
          const { marshall, unmarshall } = require('@aws-sdk/util-dynamodb');

          const db = new DynamoDBClient({ region: process.env.AWS_REGION });

          exports.handler = async (event) => {
            const response = {
              statusCode: 200,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Content-Type",
                "Access-Control-Allow-Methods": "*"
              }
            };

            try {
              const { email, firstname, lastname, profilepicture } = JSON.parse(event.body);

              const params = {
                TableName: process.env.USER_TABLE_NAME,
                Key: marshall({ email }),
                UpdateExpression: "SET #fn = :fn, #ln = :ln, #pp = :pp",
                ExpressionAttributeNames: {
                  "#fn": "firstname",
                  "#ln": "lastname",
                  "#pp": "profilepicture"
                },
                ExpressionAttributeValues: marshall({
                  ":fn": firstname || null,
                  ":ln": lastname || null,
                  ":pp": profilepicture || null
                }),
                ReturnValues: "UPDATED_NEW"
              };

              const data = await db.send(new UpdateItemCommand(params));
              const updatedUser = unmarshall(data.Attributes);

              response.body = JSON.stringify({
                message: "Successfully updated the profile.",
                data: updatedUser,
              });
            } catch (e) {
              console.error(e);
              response.statusCode = 500;
              response.body = JSON.stringify({
                message: "Failed to update the profile.",
                errorMsg: e.message,
                errorStack: e.stack,
              });
            }
            return response;
          };


  # API Gateway Resource for updating user profile
  ApiGatewayResourceUpdateUserProfile:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: update-profile

  # API Gateway Method for updating user profile
  ApiGatewayMethodUpdateUserProfile:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceUpdateUserProfile
      HttpMethod: POST
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters:
        "method.request.path.proxy": true
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceUpdateUserProfile
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${UpdateUserProfileFunction.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: { }

  # Lambda Permission for API Gateway to invoke UpdateUserProfileFunction
  UpdateUserProfileFunctionInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt UpdateUserProfileFunction.Arn
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayRestApi}/*/*/*"

  UploadFileToS3Function:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !Sub "${RoleARN}"
      Runtime: nodejs20.x
      MemorySize: 128
      Timeout: 30
      Environment:
        Variables:
          BUCKET_NAME: !Ref ComicS3Bucket
      Code:
        ZipFile: |
          const { S3Client, PutObjectCommand } = require('@aws-sdk/client-s3');

          const s3Client = new S3Client({ region: process.env.AWS_REGION });

          exports.handler = async (event) => {
            console.log('Event received:', event);

            const { filename, fileContent, contentType } = JSON.parse(event.body);
            const bucketName = process.env.BUCKET_NAME;

            try {
              const putObjectParams = {
                Bucket: bucketName,
                Key: filename,
                Body: Buffer.from(fileContent, 'base64'), // Assuming fileContent is base64 encoded
                ContentType: contentType
              };

              const putObjectCommand = new PutObjectCommand(putObjectParams);
              await s3Client.send(putObjectCommand);

              return {
                statusCode: 200,
                body: JSON.stringify({
                  message: `Successfully uploaded file ${filename} to ${bucketName}.`
                })
              };
            } catch (error) {
              console.error('Error uploading file to S3:', error);
              return {
                statusCode: 500,
                body: JSON.stringify({
                  message: 'Failed to upload file to S3',
                  error: error.message,
                  stack: error.stack
                })
              };
            }
          };





  ApiGatewayResourceUpload:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: upload

  ApiGatewayMethodUpload:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceUpload
      HttpMethod: POST
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters:
        "method.request.path.proxy": true
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceUpload
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${UploadFileToS3Function.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: { }

  UploadFileToS3FunctionInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt UploadFileToS3Function.Arn
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayRestApi}/*/*/*"


  # Edit Profile Lambda function
  EditProfileFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: "index.handler"
      Role: !Sub "${RoleARN}"
      Runtime: nodejs20.x  # Adjust runtime version as needed
      MemorySize: 128
      Timeout: 300
      Environment:
        Variables:
          USER_TABLE_NAME: !Ref UserTable
      Code:
        ZipFile: |
          const { DynamoDBClient, UpdateItemCommand } = require('@aws-sdk/client-dynamodb');
          const { marshall, unmarshall } = require('@aws-sdk/util-dynamodb');
          
          const db = new DynamoDBClient({ region: process.env.AWS_REGION });
          
          exports.handler = async (event) => {
            const response = {
              statusCode: 200,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Content-Type",
                "Access-Control-Allow-Methods": "*"
              }
            };
          
            try {
              const { email, firstname, lastname, profilepicture } = JSON.parse(event.body);
          
              const params = {
                TableName: process.env.USER_TABLE_NAME,
                Key: marshall({ email }),
                UpdateExpression: "SET #fn = :fn, #ln = :ln, #pp = :pp",
                ExpressionAttributeNames: {
                  "#fn": "firstname",
                  "#ln": "lastname",
                  "#pp": "profilepicture"
                },
                ExpressionAttributeValues: marshall({
                  ":fn": firstname || null,
                  ":ln": lastname || null,
                  ":pp": profilepicture || null
                }),
                ReturnValues: "UPDATED_NEW"
              };
          
              const data = await db.send(new UpdateItemCommand(params));
              const updatedUser = unmarshall(data.Attributes);
          
              response.body = JSON.stringify({
                message: "Successfully updated the profile.",
                data: updatedUser,
              });
            } catch (e) {
              console.error(e);
              response.statusCode = 500;
              response.body = JSON.stringify({
                message: "Failed to update the profile.",
                errorMsg: e.message,
                errorStack: e.stack,
              });
            }
            return response;
          };

  # Edit Profile Gateway resource
  ApiGatewayResourceEditProfile:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: edit-profile

  # Edit Profile Method
  ApiGatewayMethodEditProfile:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceEditProfile
      HttpMethod: POST
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters:
        "method.request.path.proxy": true
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceEditProfile
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${EditProfileFunction.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: { }

  # Edit Profile Lambda Permission
  EditProfileFunctionInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt EditProfileFunction.Arn
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayRestApi}/*/*/*"


  # Forgot Password Lambda function
  ForgotPasswordFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: "index.handler"
      Role: !Sub "${RoleARN}"
      Runtime: nodejs20.x
      MemorySize: 128
      Timeout: 30
      Environment:
        Variables:
          UserTable: !Ref UserTable
      Code:
        ZipFile: |
          const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
          const { DynamoDBDocumentClient, UpdateCommand } = require("@aws-sdk/lib-dynamodb");

          const ddbClient = new DynamoDBClient({});
          const ddbDocClient = DynamoDBDocumentClient.from(ddbClient);
          const USER_TABLE = process.env.UserTable;

          exports.handler = async (event) => {
            const response = {
              statusCode: 200,
              headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "Content-Type",
                "Access-Control-Allow-Methods": "OPTIONS,POST"
              }
            };

            try {
              // Parse the event body
              const { email, newPassword } = JSON.parse(event.body);

              if (!email || !newPassword) {
                throw new Error("Missing required fields: email, newPassword");
              }

              // Update password in DynamoDB
              await ddbDocClient.send(new UpdateCommand({
                TableName: USER_TABLE,
                Key: { email },
                UpdateExpression: 'SET password = :newPassword',
                ExpressionAttributeValues: {
                  ':newPassword': newPassword
                }
              }));

              // Respond with a success message
              return {
                ...response,
                body: JSON.stringify({
                  message: "Password update request received. Password reset instructions will be sent to your email address soon."
                })
              };
            } catch (error) {
              return {
                ...response,
                statusCode: 500,
                body: JSON.stringify({
                  message: `Error updating password: ${error.message}`
                })
              };
            }
          };

  # Forgot Password API Gateway Resource
  ApiGatewayResourceForgotPassword:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: forgot-password

  # Forgot Password Method
  ApiGatewayMethodForgotPassword:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceForgotPassword
      HttpMethod: POST
      AuthorizationType: NONE
      ApiKeyRequired: false
      RequestParameters:
        "method.request.path.proxy": true
      MethodResponses:
        - StatusCode: "200"
          ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
            method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
            method.response.header.Access-Control-Allow-Origin: "'*'"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceForgotPassword
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ForgotPasswordFunction.Arn}/invocations"
        PassthroughBehavior: "WHEN_NO_MATCH"
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
            ResponseTemplates: { }

  # Forgot Password Lambda Permission
  ForgotPasswordFunctionInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt ForgotPasswordFunction.Arn
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGatewayRestApi}/*/*/*"






  #Comic processing

  ComicProcessingFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: "index.handler"
      Role: !Sub "${RoleARN}"
      Runtime: nodejs20.x
      MemorySize: 128
      Timeout: 300
      Environment:
        Variables:
          COMIC_TABLE_NAME: !Ref ComicTable
          BUCKET_NAME: !Ref ComicS3Bucket
      Code:
        S3Bucket: "comic-lambda"
        S3Key: "ComicProcessingFunction.zip"

  ComicProcessingFunctionInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt ComicProcessingFunction.Arn
      Principal: sqs.amazonaws.com
      SourceArn: !GetAtt ComicProcessingQueue.Arn

  ComicProcessingFunctionSQSEventSourceMapping:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      EventSourceArn: !GetAtt ComicProcessingQueue.Arn
      FunctionName: !GetAtt ComicProcessingFunction.Arn
      BatchSize: 1  # Adjust batch size as per your requirement







  #proxy method so i can clear the cors error during automation of resource and service creation

  ApiGatewayMethodOptionsRoot:
    Type: "AWS::ApiGateway::Method"
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ResourceId: !Ref ApiGatewayResourceRoot
      HttpMethod: "OPTIONS"
      AuthorizationType: "NONE"
      ApiKeyRequired: false
      RequestParameters: { }
      MethodResponses:
        - ResponseModels:
            "application/json": "Empty"
          ResponseParameters:
            "method.response.header.Access-Control-Allow-Headers": false
            "method.response.header.Access-Control-Allow-Methods": false
            "method.response.header.Access-Control-Allow-Origin": false
          StatusCode: "200"
      Integration:
        CacheNamespace: !Ref ApiGatewayResourceRoot
        IntegrationResponses:
          - ResponseParameters:
              "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              "method.response.header.Access-Control-Allow-Methods": "'OPTIONS,POST,GET'"  # Update this with the allowed methods
              "method.response.header.Access-Control-Allow-Origin": "'*'"
            StatusCode: "200"
        PassthroughBehavior: "WHEN_NO_MATCH"
        RequestTemplates:
          "application/json": "{\"statusCode\": 200}"
        TimeoutInMillis: 29000
        Type: "MOCK"

  # OPTIONS method for the root resource
  ApiGatewayResourceRoot:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      ParentId: !GetAtt ApiGatewayRestApi.RootResourceId
      PathPart: "{proxy+}"

  # Common Rest API Gateway for complete backend application.
  ApiGatewayRestApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Ref Stage
      ApiKeySourceType: "HEADER"
      EndpointConfiguration:
        Types:
          - "REGIONAL"


  # API Gateway Deployment to stage.
  ApiGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - ApiGatewayMethodLogin
      - ApiGatewayMethodSignup
      - ApiGatewayMethodUserProfile
      - ApiGatewayMethodComic
      - ApiGatewayMethodComicCreation
      - ApiGatewayMethodLikeComic
      - ApiGatewayMethodSubscribe
      - ApiGatewayMethodUpload
      - ApiGatewayMethodUpdateUserProfile
      - ApiGatewayMethodEditProfile
      - ApiGatewayMethodForgotPassword
    Properties:
      RestApiId: !Ref ApiGatewayRestApi
      StageName: !Ref Stage






  #EC2 configuration
  # VPC
  ComicVerseVPC:
    Type: "AWS::EC2::VPC"
    Properties:
      CidrBlock: !Ref VpcCIDR
      EnableDnsSupport: true
      EnableDnsHostnames: true
      Tags:
        - Key: "Name"
          Value: !Sub "comicverse-vpc-${Stage}"

  # Internet Gateway
  ComicVerseInternetGateway:
    Type: "AWS::EC2::InternetGateway"
    Properties:
      Tags:
        - Key: "Name"
          Value: !Sub "comicverse-internet-gateway-${Stage}"

  # Attach Internet Gateway to VPC
  ComicVerseVPCGatewayAttachment:
    Type: "AWS::EC2::VPCGatewayAttachment"
    Properties:
      VpcId: !Ref ComicVerseVPC
      InternetGatewayId: !Ref ComicVerseInternetGateway

  # Public Subnet
  ComicVersePublicSubnet:
    Type: "AWS::EC2::Subnet"
    Properties:
      VpcId: !Ref ComicVerseVPC
      CidrBlock: !Ref PublicSubnetCIDR
      AvailabilityZone: !Sub "${AWS::Region}${AvailabilityZone}"
      MapPublicIpOnLaunch: true
      Tags:
        - Key: "Name"
          Value: !Sub "comicverse-public-subnet-${Stage}"

  # Private Subnet
  ComicVersePrivateSubnet:
    Type: "AWS::EC2::Subnet"
    Properties:
      VpcId: !Ref ComicVerseVPC
      CidrBlock: !Ref PrivateSubnetCIDR
      AvailabilityZone: !Sub "${AWS::Region}${AvailabilityZone}"
      Tags:
        - Key: "Name"
          Value: !Sub "comicverse-private-subnet-${Stage}"

  # Route Table for Public Subnet
  ComicVersePublicRouteTable:
    Type: "AWS::EC2::RouteTable"
    Properties:
      VpcId: !Ref ComicVerseVPC
      Tags:
        - Key: "Name"
          Value: !Sub "comicverse-public-route-table-${Stage}"

  # Route to Internet Gateway
  ComicVersePublicRoute:
    Type: "AWS::EC2::Route"
    DependsOn: ComicVerseVPCGatewayAttachment
    Properties:
      RouteTableId: !Ref ComicVersePublicRouteTable
      DestinationCidrBlock: "0.0.0.0/0"
      GatewayId: !Ref ComicVerseInternetGateway

  # Associate Public Subnet with Route Table
  ComicVersePublicSubnetRouteTableAssociation:
    Type: "AWS::EC2::SubnetRouteTableAssociation"
    Properties:
      SubnetId: !Ref ComicVersePublicSubnet
      RouteTableId: !Ref ComicVersePublicRouteTable

  # Security Group
  ComicVerseEC2SecurityGroup:
    Type: "AWS::EC2::SecurityGroup"
    Properties:
      GroupDescription: "Security group for ComicVerse EC2 instance"
      VpcId: !Ref ComicVerseVPC
      SecurityGroupIngress:
        - CidrIp: "0.0.0.0/0"
          FromPort: 80
          IpProtocol: "tcp"
          ToPort: 80
        - CidrIp: "0.0.0.0/0"
          FromPort: 22
          IpProtocol: "tcp"
          ToPort: 22
        - CidrIp: "0.0.0.0/0"
          FromPort: 3000
          IpProtocol: "tcp"
          ToPort: 3000
      SecurityGroupEgress:
        - CidrIp: "0.0.0.0/0"
          IpProtocol: "-1"
      Tags:
        - Key: "Name"
          Value: !Sub "comicverse-ec2-sg-${Stage}"

  # EC2 Instance
  ComicVerseEC2Instance:
    Type: "AWS::EC2::Instance"
    Properties:
      ImageId: "ami-0cd59ecaf368e5ccf" # ubuntu server
      InstanceType: "t3.small"
      KeyName: "comic-verse"
      AvailabilityZone: !Sub "${AWS::Region}${AvailabilityZone}"
      Tenancy: "default"
      SubnetId: !Ref ComicVersePublicSubnet
      EbsOptimized: true
      SecurityGroupIds:
        - !Ref ComicVerseEC2SecurityGroup
      SourceDestCheck: true
      BlockDeviceMappings:
        - DeviceName: "/dev/sdf"
          Ebs:
            Encrypted: false
            VolumeSize: 8
            SnapshotId: "snap-0d4808a4a367518ba"
            VolumeType: "gp2"
            DeleteOnTermination: true
      Tags:
        - Key: "Name"
          Value: !Sub "comicverse-ec2-${Stage}"
      HibernationOptions:
        Configured: false
      CpuOptions:
        CoreCount: 1
        ThreadsPerCore: 2
      EnclaveOptions:
        Enabled: false
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          sudo apt-get update -y
          sudo apt install npm -y
          sudo npm install -g npm@latest
          curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
          sudo apt install -y nodejs
          sudo apt install nginx -y
          sudo mkdir /var/www/html/comic-verse
          echo 'server {
            listen 80;
            listen [::]:80;
            root /var/www/html/comic-verse/build;

            #react app
            location / {
              try_files $uri /index.html;
            }
          }' | sudo tee /etc/nginx/conf.d/react.conf >/dev/null
          cd /home/ubuntu
          mkdir my-app
          cd my-app
          sudo git clone https://github.com/nikul014/cloud_term_nikul.git
          cd cloud_term_nikul
          cd comic-book-app
          # Create .env file with the API Gateway endpoint inside React app directory
          echo "REACT_APP_BASE_URL=https://${ApiGatewayRestApi}.execute-api.${AWS::Region}.amazonaws.com/${Stage}" | sudo tee .env >/dev/null  
          sudo npm install
          sudo npm run build
          sudo cp -R build/ /var/www/html/comic-verse/
          echo '
          user www-data;
          worker_processes auto;
          pid /run/nginx.pid;
          include /etc/nginx/modules-enabled/*.conf;

          events {
            worker_connections 768;
          }

          http {
            sendfile on;
            tcp_nopush on;
            tcp_nodelay on;
            keepalive_timeout 65;
            types_hash_max_size 2048;

            include /etc/nginx/mime.types;
            default_type application/octet-stream;

            ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE
            ssl_prefer_server_ciphers on;

            access_log /var/log/nginx/access.log;
            error_log /var/log/nginx/error.log;

            gzip on;

            include /etc/nginx/conf.d/*.conf;
          }' | sudo tee /etc/nginx/nginx.conf >/dev/null
          sudo nginx -t && sudo systemctl reload nginx









Outputs:

  APIGatewayEndpoint:
    Description: 'Endpoint URL of the API Gateway'
    Value: !Sub 'https://${ApiGatewayRestApi}.execute-api.${AWS::Region}.amazonaws.com'

  ComicVerseEC2InstancePublicIP:
    Description: "The public IP address of the ComicVerse EC2 instance"
    Value: !GetAtt ComicVerseEC2Instance.PublicIp
    Export:
      Name: !Sub "${AWS::StackName}-ComicVerseEC2InstancePublicIP"
